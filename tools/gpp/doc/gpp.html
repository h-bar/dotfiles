<!DOCTYPE html>
<html lang="en"><head><title>GPP 2.27 &mdash; Generic Preprocessor</title>
<meta charset="utf-8" />
<meta name="author" content="Denis Auroux, Tristan Miller">
<style>
h1 { text-align: center; }

pre { margin-left: 2ex; }

li:not(:last-child) { margin-bottom: 2ex; }
</style>
</head><body>
<h1>GPP 2.27 &mdash; Generic Preprocessor</h1>
<p>N.B. &mdash; The latest version of GPP and this manual are available from the
<strong><a href="https://logological.org/gpp/">GPP home page</a></strong>.</p>
<p><hr><h2>DESCRIPTION</h2>
<p>
GPP is a general-purpose preprocessor with customizable syntax,
suitable for a wide range of preprocessing tasks. Its independence from
any programming language makes it much more versatile than cpp,
while its syntax is lighter and more flexible than that of m4.
<p>
GPP is targeted at all common preprocessing tasks where cpp is not
suitable and where no very sophisticated features are needed. In order to be
able to process equally efficiently text files or source code in a variety
of languages, the syntax used by GPP is fully customizable. The
handling of comments and strings is especially advanced.
<p>
Initially, GPP only understands a minimal set of built-in macros,
called <i>meta-macros</i>. These meta-macros allow the definition of
<i>user macros</i> as well as some basic operations forming the core of
the preprocessing system, including conditional tests, arithmetic
evaluation, wildcard matching (globbing), and syntax
specification. All user macro definitions are global&mdash;<i>i.e.</i>,
they remain valid until explicitly removed; meta-macros cannot be
redefined. With each user macro definition GPP keeps track of the
corresponding syntax specification so that a macro can be safely
invoked regardless of any subsequent change in operating mode.
<p>
In addition to macros, GPP understands comments and strings, whose syntax
and behavior can be widely customized to fit any particular purpose.
Internally comments and strings are the same construction, so everything
that applies to comments applies to strings as well.
<p><hr><h2>SYNTAX</h2>

<pre>
gpp [-{o|O} <i>outfile</i>] [-I<i>/include/path</i> ...]
    [-D<i>name=val</i> ...] [-z|+z] [-x] [-m]
    [-C|-T|-H|-X|-P|-U ... [-M ...]]
    [-n|+n] [+c<i>&lt;n&gt;</i> <i>str1</i> <i>str2</i>] [+s<i>&lt;n&gt;</i> <i>str1</i> <i>str2</i> <i>c</i>]
    [-c <i>str1</i>] [--nostdinc] [--nocurinc]
    [--curdirinclast] [--warninglevel <i>n</i>]
    [--includemarker <i>str</i>] [--include <i>file</i>]
    [<i>infile</i>]

gpp --help

gpp --version</pre>

<p><hr><h2>OPTIONS</h2>
<p>
GPP recognizes the following command-line switches and options.  Note that
the -nostdinc, -nocurinc,
-curdirinclast, -warninglevel, and
-includemarker options from version 2.1 and earlier are
deprecated and should not be used.  Use the <q>long option</q> variants
instead (--nostdinc, <i>etc.</i>).
<ul><li>
<b>-h --help</b><br>
Print a short help message.
<li>
<b>--version</b><br>
Print version information.
<li>
<b>-o </b>outfile<br>
Specify a file to which all output should be sent (by default, everything
is sent to standard output).
<li>
<b>-O </b>outfile<br>
Specify a file to which all output should be sent; output is simultaneously
sent to stdout.
<li>
<b>-I</b>/include/path<br>
Specify a path where the <i>#include</i> meta-macro will look for include
files if they are not present in the current directory. The default is
/usr/include if no -I option is specified. Multiple
-I options may be specified to look in several directories.
<li>
<b>-D</b>name=val<br>
Define the user macro <i>name</i> as equal to <i>val</i>. This is strictly
equivalent to using the <i>#define</i> meta-macro, but makes it possible
to define macros from the command-line. If <i>val</i> makes references to
arguments or other macros, it should conform to the syntax of the mode
specified on the command-line. Starting with version 2.1, macro argument
naming is allowed on the command-line. The syntax is as follows:
-D<i>macro</i>(<i>arg1</i>,&hellip;)=<i>definition</i>. The arguments
are specified in C-style syntax, without any whitespace, but the definition
should still conform to the syntax of the mode specified on the command-line.
<li>
<b>+z</b><br>
Set text mode to Unix mode (LF terminator). Any CR character in the
input is systematically discarded. This is the default under Unix systems.
<li>
<b>-z</b><br>
Set text mode to DOS mode (CR&ndash;LF terminator). In this mode all CR
characters are removed from the input, and all output LF characters are
converted to CR&ndash;LF. This is the default if GPP is compiled with the
WIN_NT option.
<li>
<b>-x</b><br>
Enable the use of the <i>#exec</i> meta-macro. Since <i>#exec</i> includes
the output of an arbitrary shell command line, it may cause a potential
security threat, and is thus disabled unless this option is specified.
<li>
<b>-m</b><br>
Enable automatic mode switching to the cpp compatibility mode if the name
of an included file ends in `.h' or `.c'. This makes it possible to
include C header files with only minor modifications.
<li>
<b>-n</b><br>
Prevent newline or whitespace characters from being removed from the input
when they occur as the end of a macro call or of a comment. By default,
when a newline or whitespace character forms the end of a macro or a comment
it is parsed as part of the macro call or comment and therefore removed from
output. Use the -n option to keep the last character in the input
stream if it was whitespace or a newline. This is activated in cpp and Prolog
modes.
<li>
<b>+n</b><br>
The opposite of -n. This is the default in all modes except cpp
and Prolog. Note that +n must be placed <i>after</i> -C or
-P in order to have any effect.
<li>
<b>-U </b>arg1 &hellip; arg9<br>
User-defined mode. The nine following command-line arguments are taken to
be respectively the macro start sequence, the macro end sequence for a call
without arguments, the argument start sequence, the argument separator,
the argument end sequence, the list of characters to stack for argument
balancing, the list of characters to unstack, the string to be used for
referring to an argument by number, and finally the quote character (if
there is none an empty string should be provided).
These settings apply both to user macros and to meta-macros, unless the
-M option is used to define other settings for meta-macros. See
the section on syntax specification for more details.
<li>
<b>-M </b>arg1 &hellip; arg7<br>
User-defined mode specifications for meta-macros. This option can only be
used together with -U. The seven following command-line
arguments are taken to be respectively the macro start sequence, the macro
end sequence for a call without arguments, the argument start sequence,
the argument separator, the argument end sequence, the list of characters
to stack for argument balancing, and the list of characters to unstack.
See below for more details.
<li>
<b>(default mode)</b><br>
The default mode is a vaguely cpp-like mode, but it does not handle
comments, and presents various incompatibilities with cpp.
Typical meta-macros and user macros look like this: <pre>
#define x y
macro(arg,...)
</pre>
This mode is equivalent to <pre>
-U "" "" "(" "," ")" "(" ")" "#" "\\"
-M "#" "\n" " " " " "\n" "(" ")"
</pre>
<li>
<b>-C</b><br>
cpp compatibility mode. This is the mode where GPP's behavior is the
closest to that of cpp. Unlike in the default mode, meta-macro expansion
occurs only at the beginning of lines, and C comments and strings are
understood. This mode is equivalent to <pre>
-n -U "" "" "(" "," ")" "(" ")" "#" ""
-M "\n#\w" "\n" " " " " "\n" "" ""
+c "/*" "*/" +c "//" "\n" +c "\\\n" ""
+s "\"" "\"" "\\" +s "'" "'" "\\"
</pre>
<li>
<b>-T</b><br>
TeX-like mode. In this mode, typical meta-macros and user macros look like
this: <pre>
\define{x}{y}
\macro{arg}{...}
</pre>
No comments are understood. This mode is equivalent to <pre>
-U "\\" "" "{" "}{" "}" "{" "}" "#" "@"
</pre>
<li>
<b>-H</b><br>
HTML-like mode. In this mode, typical meta-macros and user macros look like
this: <pre>
&lt;#define x|y&gt;
&lt;#macro arg|...&gt;
</pre>
No comments are understood. This mode is equivalent to <pre>
-U "&lt;#" "&gt;" "\B" "|" "&gt;" "&lt;" "&gt;" "#" "\\"
</pre>
<li>
<b>-X</b><br>
XHTML-like mode. In this mode, typical meta-macros and user macros look like
this: <pre>
&lt;#define x|y/&gt;
&lt;#macro arg|.../&gt;
</pre>
No comments are understood. This mode is equivalent to <pre>
-U "&lt;#" "/&gt;" "\B" "|" "/&gt;" "&lt;" "&gt;" "#" "\\"
</pre>
<li>
<b>-P</b><br>
Prolog-compatible cpp-like mode. This mode differs from the cpp
compatibility mode by its handling of comments, and is equivalent to <pre>
-n -U "" "" "(" "," ")" "(" ")" "#" ""
-M "\n#\w" "\n" " " " " "\n" "" ""
+ccss "\!o/*" "*/" +ccss "%" "\n" +ccii "\\\n" ""
+s "\"" "\"" "" +s "\!#'" "'" ""
</pre>
<li>
<b>+c</b>&lt;n&gt; str1 str2<br>
Specify comments. Any unquoted occurrence of <i>str1</i> will be
interpreted as the beginning of a comment. All input up to the first
following occurrence of <i>str2</i> will be discarded. This
option may be used multiple times to specify different types of comment
delimiters. The optional parameter <i>&lt;n&gt;</i> can be specified to
alter the behavior of the comment and, <i>e.g.</i>, turn it into a string or make
it ignored under certain circumstances, see below.
<li>
<b>-c </b>str1<br>
Un-specify comments or strings. The comment/string specification whose
start sequence is <i>str1</i> is removed. This is useful to alter the
built-in comment specifications of a standard mode&mdash;<i>e.g.</i>, the cpp
compatibility mode.
<li>
<b>+s</b>&lt;n&gt; str1 str2 c<br>
Specify strings. Any unquoted occurrence of <i>str1</i> will be
interpreted as the beginning of a string. All input up to the first
following occurrence of <i>str2</i> will be output as is without any
evaluation. The delimiters themselves are output. If <i>c</i> is non-empty,
its first character is used as a <i>string-quote character</i>&mdash;<i>i.e.</i>, a
character whose presence immediately before an occurrence of <i>str2</i>
prevents it from terminating the string.
The optional parameter <i>&lt;n&gt;</i> can be specified to
alter the behavior of the string and, <i>e.g.</i>, turn it into a comment, enable
macro evaluation inside the string, or make the string specification
ignored under certain circumstances. See below.
<li>
<b>-s </b>str1<br>
Un-specify comments or strings. Identical to -c.
<li>
<b>--include </b>file<br>
Process <i>file</i> before <i>infile</i>
<li>
<b>--nostdinc</b><br>
Do not look for include files in the standard directory /usr/include.
<li>
<b>--nocurinc</b><br>
Do not look for include files in the current directory.
<li>
<b>--curdirinclast</b><br>
Look for include files in the current directory <i>after</i> the directories
specified by <i>-I</i> rather than before them.
<li>
<b>--warninglevel </b>n<br>
Set warning level to <i>n</i> (0, 1 or 2). Default is 2 (most verbose).
<li>
<b>--includemarker </b>str<br>
keep track of <i>#include</i> directives by inserting a marker in the
output stream. The format of the marker is determined by <i>str</i>, which
must contain three occurrences of the character <i>%</i> (or equivalently
<i>?</i>). The first occurrence is replaced with the line number, the second
with the file name, and the third with 1, 2 or blank. When this option
is specified in default, cpp or Prolog mode, GPP does its best to
ensure that line numbers are the same in the output as in the input by
inserting blank lines in the place of definitions or comments.
<li>
<b>infile</b><br>
Specify an input file from which GPP reads its input. If no input
file is specified, input is read from standard input.
</ul>
<p><hr><h2>SYNTAX SPECIFICATION</h2>
<p>
The syntax of a macro call is as follows: it must start with a
sequence of characters matching the <i>macro start sequence</i> as specified
in the current mode, followed immediately by the name of the macro, which
must be a valid <i>identifier</i>&mdash;<i>i.e.</i>, a sequence of letters, digits,
or underscores (<q>_</q>). The macro name must be followed by a <i>short
macro end sequence</i> if the macro has no arguments, or by a sequence of
arguments initiated by an <i>argument start sequence</i>. The various arguments
are then separated by an <i>argument separator</i>, and the macro ends with
a <i>long macro end sequence</i>.
<p>
In all cases, the parameters of the current context&mdash;<i>i.e.</i>, the
arguments passed to the body being evaluated&mdash;can be referred to by using
an <i>argument reference sequence</i> followed by a digit between 1 and 9.
Alternatively, macro parameters may be named (see below). Furthermore, to
avoid interference between the GPP syntax and the contents of the input file,
a <i>quote character</i> is provided. The quote character can be used to
prevent the interpretation of a macro call, comment, or string as anything
but plain text. The quote character <q>protects</q> the following character, and
always gets removed during evaluation. Two consecutive quote characters
evaluate as a single quote character.
<p>
Finally, to facilitate proper argument delimitation, certain characters can
be <q>stacked</q> when they occur in a macro argument, so that the argument
separator or macro end sequence are not parsed if the argument body is not
balanced. This allows nesting macro calls without using quotes. If an
improperly balanced argument is needed, quote characters should be added in
front of some stacked characters to make it balanced.
<p>
The macro construction sequences described above can be different for
meta-macros and for user macros: this is the case in cpp mode, for example.
Note that, since meta-macros can only have up to two arguments, the
delimitation rules for the second argument are somewhat sloppier, and
unquoted argument separator sequences are allowed in the second argument
of a meta-macro.
<p>
Unless one of the standard operating modes is selected, the above syntax
sequences can be specified either on the command-line, using the
-M and -U options respectively for meta-macros and
user macros, or inside an input file via the <i>#mode meta</i> and
<i>#mode user</i> meta-macro calls. In both cases the mode description
consists of nine parameters for user macro specifications, namely the macro
start sequence, the short macro end sequence, the argument start sequence, the
argument separator, the long macro end sequence, the string listing characters
to stack, the string listing characters to unstack, the argument reference
sequence, and finally the quote character. As explained below, these sequences
should be supplied using the syntax of C strings; they must start with a
non-alphanumeric character, and in the first five strings special matching
sequences can be used (see below). If the argument corresponding to the quote
character is the empty string, that argument's functionality is disabled. For
meta-macro specifications there are only seven parameters, as the argument
reference sequence and quote character are shared with the user macro syntax.
<p>
The structure of a comment/string is as follows: it must start with a
sequence of characters matching the given
<i>comment/string start sequence</i>, and always ends at the first occurrence
of the <i>comment/string end sequence</i>, unless it is preceded by an odd
number of occurrences of the <i>string-quote character</i> (if such a character
has been specified). In certain cases comment/strings can be specified to
enable macro evaluation inside the comment/string; in that case, if a quote
character has been defined for macros it can be used as well to prevent the
comment/string from ending, with the difference that the macro quote
character is always removed from output whereas the string-quote character is
always output. Also note that under certain circumstances a comment/string
specification can be <i>disabled</i>, in which case the comment/string start
sequence is simply ignored. Finally, it is possible to specify a <i>string
warning character</i> whose presence inside a comment/string will cause GPP to
output a warning (this is useful to locate unterminated strings in cpp mode).
Note that input files are not allowed to contain unterminated
comments/strings.
<p>
A comment/string specification can be declared from within the input
file using the <i>#mode comment</i> meta-macro call (or equivalently
<i>#mode string</i>), in which case the number of C strings to be given as
arguments to describe the comment/string can be anywhere between two and four:
the first two arguments (mandatory) are the start sequence and the end
sequence, and can make use of the special matching sequences (see below).
They may not start with alphanumeric characters. The first
character of the third argument, if there is one, is used as the string-quote
character (use an empty string to disable the functionality), and the
first character of the fourth argument, if there is one, is used as the
string-warning character. A specification may also be given from the
command-line, in which case there must be two arguments if using the
+c option and three if using the +s option.
<p>
The behavior of a comment/string is specified by a three-character
modifier string, which may be passed as an optional argument either
to the +c/+s command-line options or to the <i>#mode
comment</i>/<i>#mode string</i> meta-macros. If no modifier string is
specified, the default value is <q>ccc</q> for comments and <q>sss</q> for strings.
The first character corresponds to the behavior inside meta-macro calls
(including user-macro definitions since these come inside a <i>#define</i>
meta-macro call), the second character corresponds to the behavior inside
user-macro parameters, and the third character corresponds to the behavior
outside of any macro call. Each of these characters can take the following
values:
<ul>
<li>
<b>i:</b>
disable the comment/string specification.
<li>
<b>c:</b>
comment (neither evaluated nor output).
<li>
<b>s:</b>
string (the string and its delimiter sequences are output as-is).
<li>
<b>q:</b>
quoted string (the string is output as-is, without the delimiter sequences).
<li>
<b>C:</b>
evaluated comment (macros are evaluated, but output is discarded).
<li>
<b>S:</b>
evaluated string (macros are evaluated, delimiters are output).
<li>
<b>Q:</b>
evaluated quoted string (macros are evaluated, delimiters are not output).</ul>
<p>
Important note: any occurrence of a comment/string start sequence inside
another comment/string is always ignored, even if macro evaluation is
enabled. In other words, comments/strings cannot be nested. In particular,
the `Q' modifier can be a convenient way of defining a syntax for
temporarily disabling all comment and string specifications.
<p>
Syntax specification strings should always be provided as C strings,
whether they are given as arguments to a <i>#mode</i> meta-macro call or
on the command-line of a Unix shell. If command-line arguments are given
via another method than a standard Unix shell, then the shell behavior
must be emulated&mdash;<i>i.e.</i>, the surrounding "" quotes should be
removed, all occurrences of `\\' should be replaced by a single backslash,
and similarly `\"' should be replaced by `"'.
Sequences like `\n' are recognized by GPP and should be left as is.
<p>
Special sequences matching certain subsets of the character set can be
used. They are of the form `\<i>x</i>', where <i>x</i> is one of:
<ul>
<li>
<b>b:</b>
matches any sequence of one or more spaces or tab characters (`\b' is
identical to `&nbsp;').
<li>
<b>w:</b>
matches any sequence of zero or more spaces or tab characters.
<li>
<b>B:</b>
matches any sequence of one or more spaces, tabs or newline characters.
<li>
<b>W:</b>
matches any sequence of zero or more spaces, tabs or newline characters.
<li>
<b>a:</b>
an alphabetic character (`a' to `z' and `A' to `Z').
<li>
<b>A:</b>
an alphabetic character, or a space, tab or newline.
<li>
<b>#:</b>
a digit (`0' to `9').
<li>
<b>i:</b>
an identifier character. The set of matched characters is customizable
using the <i>#mode charset id</i> command. The default setting matches
alphanumeric characters and underscores (`a' to `z', `A' to `Z', `0' to `9'
and `_').
<li>
<b>t:</b>
a tab character.
<li>
<b>n:</b>
a newline character.
<li>
<b>o:</b>
an operator character. The set of matched characters is customizable
using the <i>#mode charset op</i> command. The default setting matches
all characters in <q>+-*/\^&lt;&gt;=`~:.?@#&!%|</q>,
except in Prolog mode where `!', `%' and `|' are not matched.
<li>
<b>O:</b>
an operator character or a parenthesis character. The set of additional
matched characters in comparison with `\o' is customizable using the
<i>#mode charset par</i> command. The default setting is to have the
characters in <q>()[]{}</q> as parentheses.</ul>
<p>
Moreover, all of these matching subsets except `\w' and `\W' can be
negated by inserting a `!'&mdash;<i>i.e.</i>, by writing `\!<i>x</i>' instead of
`\<i>x</i>'.
<p>
Note an important distinctive feature of <i>start sequences</i>: when the
first character of a macro or comment/string start sequence is `&nbsp;' or
one of the above special sequences, it is not taken to be part of the sequence
itself but is used instead as a context check: for example a start sequence
beginning with `\n' matches only at the beginning of a line, but the
matching newline character is not taken to be part of the sequence.
Similarly a start sequence beginning with `&nbsp;' matches only if some
whitespace is present, but the matching whitespace is not considered to
be part of the start sequence and is therefore sent to output. If a context
check is performed at the very beginning of a file (or more generally of
any body to be evaluated), the result is the same as matching with a newline
character (this makes it possible for a cpp-mode file to start with a
meta-macro call).
<p>
Two special syntax rules were added in version 2.1. First,
argument references (#<i>n</i>) are no longer evaluated when they are
outside of macro calls and definitions. However, they are no longer allowed
to appear (unless protected by quote characters) inside a call to a defined
user macro; the current behavior (backwards compatible) is to remove them
silently from the input if that happens.
<p>
Second, if the end sequence (either for macros or comments) consists of a
single newline character, and if delimitation rules lead
to evaluation in a context where the final newline character is absent,
GPP silently ignores the missing newline instead of producing an
error. The main consequence is that meta-macro calls can now be nested
in a simple way in standard, cpp and Prolog modes.

<p><hr><h2>EVALUATION RULES</h2>
<p>
Input is read sequentially and interpreted according to the rules of the
current mode. All input text is first matched against the specified
comment/string start sequences of the current mode (except those which
are disabled by the `i' modifier), unless the body being evaluated is
the contents of a comment/string whose modifier enables macro evaluation.
The most recently defined comment/string specifications are checked for
first. Important note: comments may not appear between the name of a macro
and its arguments (doing so results in undefined behavior).
<p>
Anything that is not a comment/string is then matched against a possible
meta-macro call, and if that fails too, against a possible user-macro
call. All remaining text undergoes substitution of argument reference
sequences by the relevant argument text (empty unless the body being
evaluated is the definition of a user macro) and removal of the quote
character if there is one.
<p>
Note that meta-macro arguments are passed to the meta-macro prior to
any evaluation (although the meta-macro may choose to evaluate them,
see meta-macro descriptions below). In the case of the <i>#mode</i>
meta-macro, GPP temporarily adds a comment/string specification to
enable recognition of C strings ("&hellip;") and prevent any evaluation
inside them, so no interference of the characters being put in the C
string arguments to <i>#mode</i> with the current syntax is to be feared.
<p>
On the other hand, the arguments to a user macro are systematically
evaluated, and then passed as context parameters to the macro definition
body, which gets evaluated with that environment. The only exception is
when the macro definition is empty, in which case its arguments are not
evaluated. Note that GPP temporarily switches back to the mode in which
the macro was defined in order to evaluate it, so it is perfectly safe
to change the operating mode between the time a macro is defined
and the time when it is called. Conversely, if a user macro wishes to
work with the current mode instead of the one that was used to define it
it needs to start with a <i>#mode restore</i> call and end with a
<i>#mode save</i> call.
<p>
A user macro may be defined with named arguments (see <i>#define</i>
description below). In that case, when the macro definition is being
evaluated, each named parameter causes a temporary virtual user-macro
definition to be created; such a macro may be called only without arguments
and simply returns the text of the corresponding argument.
<p>
Note that, since macros are evaluated when they are called rather than
when they are defined, any attempt to call a recursive macro causes
undefined behavior except in the very specific case when the macro
uses <i>#undef</i> to erase itself after finitely many loop iterations.
<p>
Finally, a special case occurs when a user macro whose definition does not
involve any arguments (neither named arguments nor the argument reference
sequence) is called in a mode where the short user-macro end sequence is
empty (<i>e.g.</i>, cpp or TeX&nbsp;mode). In that case it is assumed to be an
<i>alias macro</i>: its arguments are first evaluated in the current mode
as usual, but instead of being passed to the macro definition as parameters
(which would cause them to be discarded) they are actually appended to the
macro definition, using the syntax rules of the mode in which the macro was
defined, and the resulting text is evaluated again. It is therefore
important to note that, in the case of a macro alias, the arguments
actually get evaluated twice in two potentially different modes.
<p><hr><h2>META-MACROS</h2>
<p>
These macros are always predefined. Their actual calling sequence depends
on the current mode; here we use cpp-like notation.
<ul>
<li>
<b>#define </b>x y<br>
This defines the user macro <i>x</i> as <i>y</i>. <i>y</i> can be any valid
GPP input, and may for example refer to other macros. <i>x</i> must
be an identifier (<i>i.e.</i>, a sequence of alphanumeric characters and
`_'), unless named arguments are specified. If <i>x</i> is already defined,
the previous definition is overwritten. If no second argument is given,
<i>x</i> will be defined as a macro that outputs nothing. Neither <i>x</i>
nor <i>y</i> are evaluated; the macro definition is only evaluated when
it is called, not when it is declared.
<p>
It is also possible to name the arguments in a macro definition: in
that case, the argument <i>x</i> should be a user-macro call whose arguments
are all identifiers. These identifiers become available as user-macros
inside the macro definition; these virtual macros must be called without
arguments, and evaluate to the corresponding macro parameter.
<li>
<b>#defeval </b>x y<br>
This acts in a similar way to <i>#define</i>, but the second argument <i>y</i>
is evaluated immediately. Since user macro definitions are also evaluated
each time they are called, this means that the macro <i>y</i> will undergo
<i>two</i> successive evaluations. The usefulness of <i>#defeval</i> is
considerable as it is the only way to evaluate something more than once,
which may be needed to force evaluation of the arguments of a
meta-macro that normally doesn't perform any evaluation. However since all
argument references evaluated at define-time are understood as the arguments
of the body in which the macro is being defined and not as the arguments of
the macro itself, usually one has to use the quote character to prevent
immediate evaluation of argument references.
<li>
<b>#undef </b>x<br>
This removes any existing definition of the user macro <i>x</i>.
<li>
<b>#ifdef </b>x<br>
This begins a conditional block. Everything that follows is evaluated only
if the identifier <i>x</i> is defined, and until either a <i>#else</i> or a
<i>#endif</i> statement is reached. Note, however, that the commented text is
still scanned thoroughly, so its syntax must be valid. It is in particular
legal to have the <i>#else</i> or <i>#endif</i> statement ending the
conditional block appear only as the result of a user-macro expansion and not
explicitly in the input.
<li>
<b>#ifndef </b>x<br>
This begins a conditional block. Everything that follows is evaluated only
if the identifier <i>x</i> is not defined.
<li>
<b>#ifeq </b>x y<br>
This begins a conditional block. Everything that follows is evaluated
only if the results of the evaluations of <i>x</i> and <i>y</i> are identical
as character strings. Any leading or trailing whitespace is ignored for
the comparison. Note that in cpp-mode any unquoted whitespace character
is understood as the end of the first argument, so it is necessary to be
careful.
<li>
<b>#ifneq </b>x y<br>
This begins a conditional block. Everything that follows is evaluated only
if the results of the evaluations of <i>x</i> and <i>y</i> are not identical
(even up to leading or trailing whitespace).
<li>
<b>#else</b><br>
This toggles the logical value of the current conditional block. What
follows is evaluated if and only if the preceding input was commented out.
<li>
<b>#endif</b><br>
This ends a conditional block started by a <i>#if&hellip;</i> meta-macro.
<li>
<b>#include </b>file<br>
This causes GPP to open the specified file and evaluate its contents,
inserting the resulting text in the current output. All defined user macros
are still available in the included file, and reciprocally all macros
defined in the included file will be available in everything that
follows. The include file is looked for first in the current directory,
and then, if not found, in one of the directories specified by the <i>-I</i>
command-line option (or <i>/usr/include</i> if no directory was specified).
Note that, for compatibility reasons, it is possible to put the file name
between "" or &lt;&gt;.
<p>
The order in which the various directories are searched for include files
is affected by the <i>-nostdinc</i>, <i>-nocurinc</i> and <i>-curdirinclast</i>
command-line options.
<p>
Upon including a file, GPP immediately saves a copy of the current operating
mode onto the mode stack, and restores the operating mode at the end of the
included file. The included file may override this behavior by starting with
a <i>#mode restore</i> call and ending with a <i>#mode push</i> call.
Additionally, when the <i>-m</i> command line option is specified, GPP will
automatically switch to the cpp compatibility mode upon including a file
whose name ends with either `.c' or `.h'.
<li>
<b>#exec </b>command<br>
This causes GPP to execute the specified command line and include its standard
output in the current output. Note that, for security reasons, this meta-macro
is disabled unless the <i>-x</i> command line flag was specified.
If use of <i>#exec</i> is not allowed, a warning message is printed
and the output is left blank. Note that the specified command line is
evaluated before being executed, thus allowing the use of macros in the
command-line. However, the output of the command is included verbatim and
not evaluated. If you need the output to be evaluated, you must use
<i>#defeval</i> (see above) to cause a double evaluation.
<li>
<b>#eval </b>expr<br>
The <i>#eval</i> meta-macro attempts to evaluate <i>expr</i> first by
expanding macros (normal GPP evaluation) and then by performing
arithmetic evaluation and/or wildcard matching.  The syntax and
operator precedence for arithmetic expressions are the same as in C;
the only missing operators are &lt;&lt;, &gt;&gt;, ?:, and the assignment
operators.
<p>
POSIX-style wildcard matching (`globbing') is available only on POSIX
implementations and can be invoked with the =~ operator.  In
brief, a `?' matches any single character, a `*' matches any string
(including the empty string), and `[&hellip;]' matches any one of the
characters enclosed in brackets.  A `[&hellip;]' class is complemented
when the first character in the brackets is `!'.  The characters in a
`[&hellip;]' class can also be specified as a range using the `-'
character&mdash;<i>e.g.</i>, `[F-N]' is equivalent to `[FGHIJKLMN]'.
<p>
If unable to assign a numerical value to the result, the
returned text is simply the result of macro expansion without any
arithmetic evaluation. The only exceptions to this rule are the
comparison operators ==, !=, &lt;, &gt;, &lt;=, and &gt;= which, if one of
the sides does not evaluate to a number, perform string comparison
instead (ignoring trailing and leading spaces).  Additionally, the
<i>length(&hellip;)</i> arithmetic operator returns the length in
characters of its evaluated argument.
<p>
Inside arithmetic expressions, the <i>defined(&hellip;)</i> special user macro
is also available: it takes only one argument, which is not evaluated, and
returns 1 if it is the name of a user macro and 0 otherwise.
<li>
<b>#if </b>expr<br>
This meta-macro invokes the arithmetic/globbing evaluator in the same
manner as <i>#eval</i> and compares the result of evaluation with the
string "0" in order to begin a conditional block. In particular note
that the logical value of <i>expr</i> is always true when it cannot be
evaluated to a number.
<li>
<b>#elif </b>expr<br>
This meta-macro can be used to avoid nested <i>#if</i> conditions.
<i>#if</i> &hellip; <i>#elif</i> &hellip; <i>#endif</i> is equivalent
to <i>#if</i> &hellip; <i>#else</i> <i>#if</i> &hellip;
<i>#endif</i> <i>#endif</i>.
<li>
<b>#mode </b>keyword &hellip;<br>
This meta-macro controls GPP's operating mode. See below for a list of
<i>#mode</i> commands.
<li>
<b>#line</b><br>
This meta-macro evaluates to the line number of the current input file.
<li>
<b>#file</b><br>
This meta-macro evaluates to the filename of the current input file as
it appears on the command line or in the argument to <i>#include</i>.
If GPP is reading its input from stdin, then <i>#file</i> evaluates
to `stdin'.
<li>
<b>#date </b>fmt<br>
This meta-macro evaluates to the current date and time as formatted by
the specified format string <i>fmt</i>.  See the section <i>DATE AND
TIME CONVERSION SPECIFIERS</i> below.
<li>
<b>#error </b>msg<br>
This meta-macro causes an error message with the current filename and
line number, and with the text <i>msg</i>, to be printed to the standard
error device.  Subsequent processing is then aborted.
<li>
<b>#warning </b>msg<br>
This meta-macro causes a warning message with the current filename and
line number, and with the text <i>msg</i>, to be printed to the standard
error device.  Subsequent processing is then resumed.
</ul>
<p>
The key to GPP's flexibility is the <i>#mode</i> meta-macro. Its first
argument is always one of a list of available keywords (see below);
its second argument is always a sequence of words separated by whitespace.
Apart from possibly the first of them, each of these words is always a
delimiter or syntax specifier, and should be provided as a C string
delimited by double quotes ("&nbsp;"). The various special matching
sequences  listed in the section on syntax specification are available. Any
<i>#mode</i> command is parsed in a mode where "&hellip;" is understood
to be a C-style string, so it is safe to put any character inside these
strings. Also note that the first argument of <i>#mode</i> (the keyword) is
never evaluated, while the second argument is evaluated (except of course for
the contents of C strings), so that the syntax specification may be obtained
as the result of a macro evaluation.
<p>
The available <i>#mode</i> commands are:
<ul>
<li>
<b>#mode save / #mode push</b><br>
Push the current mode specification onto the mode stack.
<li>
<b>#mode restore / #mode pop</b><br>
Pop mode specification from the mode stack.
<li>
<b>#mode standard </b>name<br>
Select one of the standard modes. The only argument must be one of:
default (default mode); cpp, C (cpp mode); tex, TeX (TeX&nbsp;mode); html,
HTML (html mode); xhtml, XHTML (xhtml mode); prolog, Prolog (prolog
mode). The mode name must be given directly, not as a C string.
<li>
<b>#mode user </b>"s1" &hellip; "s9"<br>
Specify user macro syntax.
The 9 arguments, all of them C strings, are the mode specification for
user macros (see the -U command-line option and the section on
syntax specification). The meta-macro specification is not affected.
<li>
<b>#mode meta </b>{user | "s1" &hellip; "s7"}<br>
Specify meta-macro syntax.
Either the only argument is <i>user</i> (not as a string), and the user-macro
mode specifications are copied into the meta-macro mode specifications,
or there must be seven string arguments, whose significance is the same as
for the -M command-line option (see section on syntax
specification).
<li>
<b>#mode quote </b>["c"]<br>
With no argument or "" as argument, removes the quote character
specification and disables the quoting functionality. With one string
argument, the first character of the string is taken to be the new
quote character. The quote character can be neither alphanumeric nor `_',
nor can it be one of the special matching sequences.
<li>
<b>#mode comment </b>[xxx] "start" "end" ["c" ["c"]]<br>
Add a comment specification. Optionally a first argument consisting of
three characters not enclosed in "&nbsp;" can be used to specify a
comment/string modifier (see the section on syntax specification). The
default modifier is <i>ccc</i>. The first two string
arguments are used as comment start and end sequences respectively.
The third string argument is optional and can be used to specify a
string-quote character. (If it is "", the functionality is disabled.)
The fourth string argument is optional and can be used to specify a
string delimitation warning character. (If it is "", the functionality
is disabled.)
<li>
<b>#mode string </b>[xxx] "start" "end" ["c" ["c"]]<br>
Add a string specification. Identical to <i>#mode comment</i> except that
the default modifier is <i>sss</i>.
<li>
<b>#mode nocomment / #mode nostring </b>["start"]<br>
With no argument, remove all comment/string specifications. With one
string argument, delete the comment/string specification whose start
sequence is the argument.
<li>
<b>#mode preservelf </b>{ on | off | 1 | 0 }<br>
Equivalent to the <i>-n</i> command-line switch. If the argument is <i>on</i>
or <i>1</i>, any newline or whitespace character terminating a macro call or
a comment/string is left in the input stream for further processing. If the
argument is <i>off</i> or <i>0</i> this feature is disabled.
<li>
<b>#mode charset </b>{ id | op | par } "string"<br>
Specify the character sets to be used for matching the \o, \O and
\i special sequences. The first argument must be one of <i>id</i>
(the set matched by \i), <i>op</i> (the set matched by \o) or <i>par</i>
(the set matched by \O in addition to the one matched by \o).
<i>"string"</i> is a C string which lists all characters to put in the
set. It may contain only the special matching sequences \a, \A, \b, \B,
and \# (the other sequences and the negated sequences are not allowed).
When a `-' is found inbetween two non-special characters this adds all
characters inbetween (e.g. "A-Z" corresponds to all uppercase
characters). To have `-' in the matched set, either put it in first or last
position or place it next to a \x sequence.
</ul>
<p><hr><h2>DATE AND TIME CONVERSION SPECIFIERS</h2>
Ordinary characters placed in the format string are copied without
conversion.  Conversion specifiers are introduced by a `%'
character, and are replaced as follows:
<ul>
<li>
<b>%a</b><br>
The abbreviated weekday name according to the  current locale.
<li>
<b>%A</b><br>
The  full  weekday  name  according  to the current
locale.
<li>
<b>%b</b><br>
The abbreviated month name according to the current
locale.
<li>
<b>%B</b><br>
The  full  month  name  according  to  the  current
locale.
<li>
<b>%c</b><br>
The preferred date and time representation for  the
current locale.
<li>
<b>%d</b><br>
The day of the month as a decimal number (range  01
to 31).
<li>
<b>%F</b><br>
Equivalent to %Y-%m-%d (the ISO 8601 date  format).
<li>
<b>%H</b><br>
The  hour as a decimal number using a 24-hour clock
(range 00 to 23).
<li>
<b>%I</b><br>
The hour as a decimal number using a 12-hour  clock
(range 01 to 12).
<li>
<b>%j</b><br>
The  day of the year as a decimal number (range 001
to 366).
<li>
<b>%m</b><br>
The month as a decimal number (range 01 to 12).
<li>
<b>%M</b><br>
The minute as a decimal number (range 00 to 59).
<li>
<b>%p</b><br>
Either `AM' or `PM' according  to  the  given  time
value, or the corresponding strings for the current
locale.  Noon is treated as `PM'  and  midnight  as
`AM'.
<li>
<b>%R</b><br>
The  time  in  24-hour notation (%H:%M).
<li>
<b>%S</b><br>
The second as a decimal number (range 00 to 61).
<li>
<b>%U</b><br>
The week number of the current year  as  a  decimal
number,  range  00  to  53, starting with the first
Sunday as the first day of week 01.
<li>
<b>%w</b><br>
The  day  of  the  week as a decimal, range 0 to 6,
Sunday being 0.
<li>
<b>%W</b><br>
The week number of the current year  as  a  decimal
number,  range  00  to  53, starting with the first
Monday as the first day of week 01.
<li>
<b>%x</b><br>
The preferred date representation for  the  current
locale without the time.
<li>
<b>%X</b><br>
The  preferred  time representation for the current
locale without the date.
<li>
<b>%y</b><br>
The year as a  decimal  number  without  a  century
(range 00 to 99).
<li>
<b>%Y</b><br>
The year as a decimal number including the century.
<li>
<b>%Z</b><br>
The time zone or name or abbreviation.
<li>
<b>%%</b><br>
A literal `%' character.
</ul>
<p>
Depending on the C compiler and library used to compile GPP, there
may be more conversion specifiers available.  Consult your compiler's
documentation for the <i>strftime()</i> function.  Note, however, that
any conversion specifiers not listed above may not be portable
across installations of GPP.
<p><hr><h2>EXAMPLES</h2>
Here is a basic self-explanatory example in standard or cpp mode:
<pre>
#define FOO This is
#define BAR a message.
#define concat #1 #2
concat(FOO,BAR)
#ifeq (concat(foo,bar)) (foo bar)
This is output.
#else
This is not output.
#endif
</pre>
Using argument naming, the <i>concat</i> macro could alternatively be defined
as
<pre>
#define concat(x,y) x y
</pre>
In TeX&nbsp;mode and using argument naming, the same example becomes:
<pre>
\define{FOO}{This is}
\define{BAR}{a message.}
\define{\concat{x}{y}}{\x \y}
\concat{\FOO}{\BAR}
\ifeq{\concat{foo}{bar}}{foo bar}
This is output.
\else
This is not output.
\endif
</pre>
In HTML mode and without argument naming, one gets similarly:
<pre>
&lt;#define FOO|This is&gt;
&lt;#define BAR|a message.&gt;
&lt;#define concat|#1 #2&gt;
&lt;#concat &lt;#FOO&gt;|&lt;#BAR&gt;&gt;
&lt;#ifeq &lt;#concat foo|bar&gt;|foo bar&gt;
This is output.
&lt;#else&gt;
This is not output.
&lt;#endif&gt;
</pre>
The following example (in standard mode) illustrates the use of
the quote character:
<pre>
#define FOO This is \
   a multiline definition.
#define BLAH(x) My argument is x
BLAH(urf)
\BLAH(urf)
</pre>
Note that the multiline definition is also valid in cpp and Prolog
modes despite the absence of quote character, because `\' followed
by a newline is then interpreted as a comment and discarded.
<p>
In cpp mode, C strings and comments are understood as such, as illustrated
by the following example:
<pre>
#define BLAH foo
BLAH "BLAH" /* BLAH */
`It\'s a /*string*/ !'
</pre>
The main difference between Prolog mode and cpp mode is the handling of
strings and comments: in Prolog, a `&hellip;' string may not begin
immediately after a digit, and a /*&hellip;*/ comment may not begin immediately
after an operator character. Furthermore, comments are not removed from
the output unless they occur in a #command.
<p>
The differences between cpp mode and default mode are deeper: in default
mode #commands may start anywhere, while in cpp mode they must be at the
beginning of a line; the default mode has no knowledge of comments and
strings, but has a quote character (`\'), while cpp mode has extensive
comment/string specifications but no quote character. Moreover, the
arguments to meta-macros need to be correctly parenthesized in default
mode, while no such checking is performed in cpp mode.
<p>
This makes it easier to nest meta-macro calls in default mode than in
cpp mode. For example, consider the following HTML mode input, which
tests for the availability of the <i>#exec</i> command:
<pre>
&lt;#ifeq &lt;#exec echo blah&gt;|blah
&gt; #exec allowed &lt;#else&gt; #exec not allowed &lt;#endif&gt;
</pre>
There is no cpp mode equivalent, while in default mode it can be easily
translated as
<pre>
#ifeq (#exec echo blah
) (blah
)
\#exec allowed
#else
\#exec not allowed
#endif
</pre>
In order to nest meta-macro calls in cpp mode it is necessary to modify
the mode description, either by changing the meta-macro call syntax, or
more elegantly by defining a silent string and using the fact that the
context at the beginning of an evaluated string is a newline character:
<pre>
#mode string QQQ "$" "$"
#ifeq $#exec echo blah
$ $blah
$
\#exec allowed
#else
\#exec not allowed
#endif
</pre>
Note, however, that comments/strings cannot be nested ("&hellip;"
inside $&hellip;$ would go undetected), so one needs to be careful
about what to include inside such a silent evaluated string. In this example,
the loose meta-macro nesting introduced in version 2.1 makes it possible to use
the following simpler version:
<pre>
#ifeq blah #exec echo -n blah
\#exec allowed
#else
\#exec not allowed
#endif
</pre>
Remember that macros without arguments are actually understood to be
aliases when they are called with arguments, as illustrated by the
following example (default or cpp mode):
<pre>
#define DUP(x) x x
#define FOO and I said: DUP
FOO(blah)
</pre>
The usefulness of the <i>#defeval</i> meta-macro is shown by the following
example in HTML mode:
<pre>
&lt;#define APPLY|&lt;#defeval TEMP|&lt;\##1 \#1&gt;&gt;&lt;#TEMP #2&gt;&gt;
&lt;#define &lt;#foo x&gt;|&lt;#x&gt; and &lt;#x&gt;&gt;
&lt;#APPLY foo|BLAH&gt;
</pre>
The reason why <i>#defeval</i> is needed is that, since everything is
evaluated in a single pass, the input that will result in the desired macro
call needs to be generated by a first evaluation of the arguments passed to
APPLY before being evaluated a second time.
<p>
To translate this example in default mode, one needs to resort to
parenthesizing in order to nest the #defeval call inside the definition
of APPLY, but need to do so without outputting the parentheses. The
easiest solution is
<pre>
#define BALANCE(x) x
#define APPLY(f,v) BALANCE(#defeval TEMP f
TEMP(v))
#define foo(x) x and x
APPLY(\foo,BLAH)
</pre>
As explained above the simplest version in cpp mode relies on defining
a silent evaluated string to play the role of the BALANCE macro.
<p>
The following example (default or cpp mode) demonstrates arithmetic
evaluation:
<pre>
#define x 4
The answer is:
#eval x*x + 2*(16-x) + 1998%x

#if defined(x)&&!(3*x+5&gt;17)
This should be output.
#endif
</pre>
To finish, here are some examples involving mode switching.
The following example is self-explanatory (starting in default mode):
<pre>
#mode push
#define f(x) x x
#mode standard tex
\f{blah}
\mode{string}{"$" "$"}
\mode{comment}{"/*" "*/"}
$\f{urf}$ /* blah */
\define{FOO}{bar/* and some more */}
\mode{pop}
f($FOO$)
</pre>
A good example where a user-defined mode becomes useful is the GPP
source of this document (available with GPP's source code distribution).
<p>
Another interesting application is selectively forcing evaluation of macros
in C strings when in cpp mode. For example, consider the following input:
<pre>
#define blah(x) "and he said: x"
blah(foo)
</pre>
Obviously one would want the parameter <i>x</i> to be expanded inside the
string. There are several ways around this problem:
<pre>
#mode push
#mode nostring "\""
#define blah(x) "and he said: x"
#mode pop

#mode quote "`"
#define blah(x) `"and he said: x`"

#mode string QQQ "$$" "$$"
#define blah(x) $$"and he said: x"$$
</pre>
The first method is very natural, but has the inconvenience of being lengthy
and neutralizing string semantics, so that having an unevaluated instance
of `x' in the string, or an occurrence of `/*', would be impossible without
resorting to further contortions. <p>
The second method is slightly more efficient because the local presence of a
quote character makes it easier to control what is evaluated and what isn't,
but has the drawback that it is sometimes impossible to find a reasonable
quote character without having to either significantly alter the source file
or enclose it inside a <i>#mode push/pop</i> construct. For example, any
occurrence of `/*' in the string would have to be quoted.<p>
The last method demonstrates the efficiency of evaluated strings in the
context of selective evaluation: since comments/strings cannot be nested,
any occurrence of `"' or `/*' inside the `$$' gets output as
plain text, as expected inside a string, and only macro evaluation is enabled.
Also note that there is much more freedom in the choice of a string delimiter
than in the choice of a quote character.
<p>
Starting with version 2.1, meta-macro calls can be nested more efficiently
in default, cpp and Prolog modes. This makes it easy to make a user
version of a meta-macro, or to increment a counter:
<pre>
#define myeval #eval #1

#define x 1
#defeval x #eval x+1
</pre>
<p><hr><h2>ADVANCED EXAMPLES</h2>
<p>
Here are some examples of advanced constructions using GPP. They tend to
be pretty awkward and should be considered as evidence of GPP's limitations.
<p>
The first example is a recursive macro. The main problem is that (since GPP
evaluates everything) a recursive macro must be very careful about the way
in which recursion is terminated in order to avoid undefined behavior (most
of the time GPP will simply crash). In particular, relying on a
<i>#if/#else/#endif</i> construct to end recursion is not possible and
results in an infinite loop, because GPP scans user macro calls even in the
unevaluated branch of the conditional block. A safe way to proceed is for
example as follows (we give the example in TeX&nbsp;mode):
<pre>
\define{countdown}{
  \if{#1}
  #1...
  \define{loop}{\countdown}
  \else
  Done.
  \define{loop}{}
  \endif
  \loop{\eval{#1-1}}
}
\countdown{10}
</pre><p>
Another example, in cpp mode:
<pre>
#mode string QQQ "$" "$"
#define triangle(x,y) y \
 $#if length(y)&lt;x$ $#define iter triangle$ $#else$ \
 $#define iter$ $#endif
$ iter(x,*y)
triangle(20)
</pre><p>
The following is an (unfortunately very weak) attempt at implementing
functional abstraction in GPP (in standard mode). Understanding this
example and why it can't be made much simpler is an exercise left to the
curious reader.
<pre>
#mode string "`" "`" "\\"
#define ASIS(x) x
#define SILENT(x) ASIS()
#define EVAL(x,f,v) SILENT(
  #mode string QQQ "`" "`" "\\"
  #defeval TEMP0 x
  #defeval TEMP1 (
    \#define \TEMP2(TEMP0) f
  )
  TEMP1
  )TEMP2(v)
#define LAMBDA(x,f,v) SILENT(
  #ifneq (v) ()
  #define TEMP3(a,b,c) EVAL(a,b,c)
  #else
  #define TEMP3(a,b,c) \LAMBDA(a,b)
  #endif
  )TEMP3(x,f,v)
#define EVALAMBDA(x,y) SILENT(
  #defeval TEMP4 x
  #defeval TEMP5 y
  )
#define APPLY(f,v) SILENT(
  #defeval TEMP6 ASIS(\EVA)f
  TEMP6
  )EVAL(TEMP4,TEMP5,v)
</pre>
This yields the following results:
<pre>
LAMBDA(z,z+z)
  =&gt; LAMBDA(z,z+z)

LAMBDA(z,z+z,2)
  =&gt; 2+2

#define f LAMBDA(y,y*y)
f
  =&gt; LAMBDA(y,y*y)

APPLY(f,blah)
  =&gt; blah*blah

APPLY(LAMBDA(t,t t),(t t))
  =&gt; (t t) (t t)

LAMBDA(x,APPLY(f,(x+x)),urf)
  =&gt; (urf+urf)*(urf+urf)

APPLY(APPLY(LAMBDA(x,LAMBDA(y,x*y)),foo),bar)
  =&gt; foo*bar

#define test LAMBDA(y,`#ifeq y urf
y is urf#else
y is not urf#endif
`)
APPLY(test,urf)
  =&gt; urf is urf

APPLY(test,foo)
  =&gt; foo is not urf
</pre>
<p><hr><h2>AUTHOR</h2>
GPP was written by Denis Auroux &lt;auroux@math.mit.edu&gt;.
Since version 2.12 it has been maintained by Tristan Miller
&lt;tristan@logological.org&gt;.
<p><hr><h2>COPYRIGHT</h2>
Copyright &copy;&nbsp;1996&ndash;2001 Denis Auroux.<br>
Copyright &copy;&nbsp;2003&ndash;2020 Tristan Miller.<p>
Permission is granted to anyone to make or distribute verbatim copies
of this document as received, in any medium, provided that the
copyright notice and this permission notice are preserved, thus giving
the recipient permission to redistribute in turn.<p>
Permission is granted to distribute modified versions of this
document, or of portions of it, under the above conditions, provided
also that they carry prominent notices stating who last changed them.
</body></html>
